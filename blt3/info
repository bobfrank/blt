no reserved keywords

symbols
@ -- chunk of code to execute (only for macros)
` -- assembly (probably similar to LLVM with some extra stuff)
need to decide what to do with calling chunks of code
maybe %(code) would represent having blt code inside of assembly code

$0 in a macro would represent a unique value common to that particular instantiation of the macro (as in just one case in a switch/case series)
$1 would represent a unique value common to the whole macro expansion (as in all items in an if/else series or switch/case series)
$name wolud represent a variable name to be used for scoping in the event that it is desired in a macro (see for loop for an example)

& -- refs
* -- pointers (and derefs)
etc (pretty much the same as C)

// start of a formal grammar (trying to avoid left recursive parse trees so I can try to use recursive descent parser)
code = codetype code
    | codetype
codetype = macro
    | NUMBER
    | STRING
    | ASSEMBLY
macro = macroprefix block
     | macroprefix
block = INDENT code DEDENT
macroprefix = macroelem macroprefix
        | macroelem
        | macroelem '...' ID
macroelem = ID args
    | DOLLAR_ID args
    | ID
    | DOLLAR_ID
    | AT_ID
    | '@'
args = '(' argvals ')'
    | '(' argvals ',' '...' ')'
    | '(' argvals ',' '...' ID ')'
argvals = macroprefix ',' argvals
        | macroprefix

everything is either a macro definition or a macro call
@ by itself will force a block to exist with the following items, e.g. useful for building a struct or listing out all types
function definitions are another macro expansion

an idea (see whitespace98.pdf) is to allow overloading whitespace, blt3 is probably already capable without changes.
still need to figure out scoping issues

because type information isn't defined in the language, nor are objects, nor are functions, it can be used as
both a statically typed language and dynamically typed language by just using different libraries.
